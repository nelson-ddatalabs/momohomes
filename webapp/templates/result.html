<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Optimization Results - Cassette Floor Plan Optimizer</title>

    <!-- Bootstrap 5 CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">
</head>
<body>
    <div class="container py-5">
        <!-- Header -->
        <div class="row mb-4">
            <div class="col-12 text-center">
                <h1 class="display-5 mb-3">‚úÖ Optimization Complete!</h1>
                <p class="lead text-muted">Your optimized floor plan is ready</p>
            </div>
        </div>

        <!-- Results Section -->
        <div class="row">
            <!-- Left Column: SVG Display -->
            <div class="col-12 col-lg-8 mb-4">
                <div class="card shadow-sm">
                    <div class="card-body">
                        <h4 class="card-title mb-3">Optimized Layout</h4>

                        <!-- Zoom Controls -->
                        <div class="d-flex justify-content-between align-items-center mb-2">
                            <div class="btn-group" role="group">
                                <button type="button" class="btn btn-sm btn-outline-secondary" id="zoom-out" title="Zoom Out (Mouse Wheel Down)">
                                    <span style="font-size: 18px;">‚àí</span>
                                </button>
                                <button type="button" class="btn btn-sm btn-outline-secondary" id="zoom-reset" title="Reset View">
                                    <span style="font-size: 14px;">100%</span>
                                </button>
                                <button type="button" class="btn btn-sm btn-outline-secondary" id="zoom-in" title="Zoom In (Mouse Wheel Up)">
                                    <span style="font-size: 18px;">+</span>
                                </button>
                            </div>
                            <small class="text-muted">Drag to pan ‚Ä¢ Scroll to zoom ‚Ä¢ Arrow keys to move</small>
                        </div>

                        <div class="border rounded p-2 bg-light" id="svg-container" style="overflow: hidden; position: relative; height: 600px; cursor: grab;">
                            <img
                                id="svg-image"
                                src="/results/{{ session_id }}/cassette_layout.svg"
                                alt="Floor plan layout"
                                style="position: absolute; transform-origin: 0 0; user-select: none; pointer-events: none;">
                        </div>
                    </div>
                </div>
            </div>

            <!-- Right Column: Statistics & Download -->
            <div class="col-12 col-lg-4">
                <!-- Statistics Card -->
                <div class="card shadow-sm mb-4">
                    <div class="card-body">
                        <h4 class="card-title mb-4">üìä Statistics</h4>

                        <div class="mb-3">
                            <label class="text-muted small">Total Area</label>
                            <h5>{{ "%.1f"|format(statistics.total_area) }} sq ft</h5>
                        </div>

                        <div class="mb-3">
                            <label class="text-muted small">Coverage</label>
                            <h5 class="text-success">{{ "%.2f"|format(statistics.coverage_percent) }}%</h5>
                        </div>

                        <div class="mb-3">
                            <label class="text-muted small">Cassettes</label>
                            <h5>{{ statistics.cassette_count }} units</h5>
                        </div>

                        <div class="mb-3">
                            <label class="text-muted small">Cassette Area</label>
                            <h5>{{ "%.1f"|format(statistics.cassette_area) }} sq ft</h5>
                        </div>

                        <div class="mb-3">
                            <label class="text-muted small">C-Channel Area</label>
                            <h5>{{ "%.1f"|format(statistics.cchannel_area) }} sq ft</h5>
                        </div>
                    </div>
                </div>

                <!-- Download Card -->
                <div class="card shadow-sm mb-4">
                    <div class="card-body">
                        <h5 class="card-title mb-3">üì• Download</h5>
                        <div class="d-grid">
                            <a href="/download/{{ session_id }}/svg" class="btn btn-primary btn-lg mb-2">
                                Download SVG
                            </a>
                            <a href="/download/{{ session_id }}/png" class="btn btn-outline-primary btn-lg">
                                Download PNG
                            </a>
                        </div>
                    </div>
                </div>

                <!-- Start New Button -->
                <div class="d-grid">
                    <a href="/" class="btn btn-outline-secondary btn-lg">
                        ‚Üê Start New Optimization
                    </a>
                </div>
            </div>
        </div>
    </div>

    <!-- Bootstrap 5 JS Bundle -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>

    <!-- Pan & Zoom Script -->
    <script>
        (function() {
            const container = document.getElementById('svg-container');
            const image = document.getElementById('svg-image');
            const zoomInBtn = document.getElementById('zoom-in');
            const zoomOutBtn = document.getElementById('zoom-out');
            const zoomResetBtn = document.getElementById('zoom-reset');

            let scale = 1;
            let translateX = 0;
            let translateY = 0;
            let isDragging = false;
            let startX = 0;
            let startY = 0;

            const MIN_SCALE = 0.1;
            const MAX_SCALE = 5;
            const ZOOM_STEP = 0.2;
            const PAN_STEP = 50;

            function updateTransform() {
                image.style.transform = `translate(${translateX}px, ${translateY}px) scale(${scale})`;
                zoomResetBtn.innerHTML = `<span style="font-size: 14px;">${Math.round(scale * 100)}%</span>`;
            }

            function centerImage() {
                const containerRect = container.getBoundingClientRect();
                const imageRect = image.getBoundingClientRect();
                translateX = (containerRect.width - imageRect.width) / 2;
                translateY = (containerRect.height - imageRect.height) / 2;
                updateTransform();
            }

            // Initialize: center the image when loaded
            image.onload = function() {
                centerImage();
            };
            if (image.complete) {
                centerImage();
            }

            // Zoom In
            zoomInBtn.addEventListener('click', () => {
                if (scale < MAX_SCALE) {
                    const oldScale = scale;
                    scale = Math.min(MAX_SCALE, scale + ZOOM_STEP);
                    // Zoom towards center
                    const rect = container.getBoundingClientRect();
                    const centerX = rect.width / 2;
                    const centerY = rect.height / 2;
                    translateX = centerX - (centerX - translateX) * (scale / oldScale);
                    translateY = centerY - (centerY - translateY) * (scale / oldScale);
                    updateTransform();
                }
            });

            // Zoom Out
            zoomOutBtn.addEventListener('click', () => {
                if (scale > MIN_SCALE) {
                    const oldScale = scale;
                    scale = Math.max(MIN_SCALE, scale - ZOOM_STEP);
                    // Zoom towards center
                    const rect = container.getBoundingClientRect();
                    const centerX = rect.width / 2;
                    const centerY = rect.height / 2;
                    translateX = centerX - (centerX - translateX) * (scale / oldScale);
                    translateY = centerY - (centerY - translateY) * (scale / oldScale);
                    updateTransform();
                }
            });

            // Reset Zoom
            zoomResetBtn.addEventListener('click', () => {
                scale = 1;
                centerImage();
            });

            // Mouse Wheel Zoom
            container.addEventListener('wheel', (e) => {
                e.preventDefault();
                const rect = container.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                const oldScale = scale;
                if (e.deltaY < 0) {
                    scale = Math.min(MAX_SCALE, scale + ZOOM_STEP);
                } else {
                    scale = Math.max(MIN_SCALE, scale - ZOOM_STEP);
                }

                // Zoom towards mouse position
                translateX = mouseX - (mouseX - translateX) * (scale / oldScale);
                translateY = mouseY - (mouseY - translateY) * (scale / oldScale);
                updateTransform();
            });

            // Mouse Drag Pan
            container.addEventListener('mousedown', (e) => {
                isDragging = true;
                startX = e.clientX - translateX;
                startY = e.clientY - translateY;
                container.style.cursor = 'grabbing';
            });

            document.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    translateX = e.clientX - startX;
                    translateY = e.clientY - startY;
                    updateTransform();
                }
            });

            document.addEventListener('mouseup', () => {
                isDragging = false;
                container.style.cursor = 'grab';
            });

            // Arrow Keys Pan
            document.addEventListener('keydown', (e) => {
                if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
                    e.preventDefault();
                    switch(e.key) {
                        case 'ArrowUp':
                            translateY += PAN_STEP;
                            break;
                        case 'ArrowDown':
                            translateY -= PAN_STEP;
                            break;
                        case 'ArrowLeft':
                            translateX += PAN_STEP;
                            break;
                        case 'ArrowRight':
                            translateX -= PAN_STEP;
                            break;
                    }
                    updateTransform();
                }
            });

            // Touch support for mobile
            let touchStartDist = 0;
            let touchStartScale = 1;

            container.addEventListener('touchstart', (e) => {
                if (e.touches.length === 2) {
                    const dx = e.touches[0].clientX - e.touches[1].clientX;
                    const dy = e.touches[0].clientY - e.touches[1].clientY;
                    touchStartDist = Math.sqrt(dx * dx + dy * dy);
                    touchStartScale = scale;
                } else if (e.touches.length === 1) {
                    isDragging = true;
                    startX = e.touches[0].clientX - translateX;
                    startY = e.touches[0].clientY - translateY;
                }
            });

            container.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if (e.touches.length === 2) {
                    const dx = e.touches[0].clientX - e.touches[1].clientX;
                    const dy = e.touches[0].clientY - e.touches[1].clientY;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    scale = Math.max(MIN_SCALE, Math.min(MAX_SCALE, touchStartScale * (dist / touchStartDist)));
                    updateTransform();
                } else if (e.touches.length === 1 && isDragging) {
                    translateX = e.touches[0].clientX - startX;
                    translateY = e.touches[0].clientY - startY;
                    updateTransform();
                }
            });

            container.addEventListener('touchend', () => {
                isDragging = false;
                touchStartDist = 0;
            });
        })();
    </script>
</body>
</html>
